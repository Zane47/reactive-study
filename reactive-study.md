# 响应式编程概念

## 什么是响应式编程

响应式编程是一种面向**数据流**和变化传播的声明式的编程范式

重要概念: 数据流. 数据流可以是一个个需要处理的数据. 例如每笔交易的订单的数据, 也可以是一个个待响应的事件. 例如用户浏览网页时点击鼠标的操作

在编程语言中声明好了静态或者动态数据流之后, 就可以通过相关计算模型自动将变化的值通过数据流的逻辑进行传播. -> 这就是响应式编程

## 响应式编程特点

### 事件驱动

基于观察者设计模式

![image-20220503221408729](img/reactive-study/image-20220503221408729.png)

观察对象subject管理所有的依赖于它的观察者列表Observer, 当观察对象状态发生变化的时候会主动发出通知, 例如调用notifyObservers方法, 此时他会遍历所有注册在上面的观察者列表, 对每一个观察者调用concrete.notify方法通知观察者你所关注的对象的状态发生了变化.

系统中有多种事件, 例如连接db, 接受http请求等. 响应式编程的愿景就是**完全的事件驱动**. 从第一个事件被触发开始依次按照声明好的事件传播链路来处理. 后续的读取和返回都是对第一个事件的响应. -> 完全响应式的框架

### 异步代码编排

以往的java中使用callback回调函数的形式, 问题: 可能过于冗长. 

<img src="img/reactive-study/image-20220522164540902.png" alt="image-20220522164540902" style="zoom:50%;" />

逻辑: 读MQ -> post请求 -> 查找数据库 -> 写MQ

多层嵌套回调函数, 为了避免这种冗余的回调, 在响应式中可以这么实现

<img src="img/reactive-study/image-20220522165028949.png" alt="image-20220522165028949" style="zoom:50%;" />

也可以使用jdk8中的CompletableFuture也可以实现, 但是对于复杂逻辑处理不够理想. -> 响应式提供丰富的操作符简化异步逻辑编排

## 响应式流JVM规范

https://github.com/reactive-streams/reactive-streams-jvm

NetFlix – RxJava, Pivotal – Reactor, RedHat – Vert.x

* 处理任意数量的元素 -> 可以处理无限元素的数据流. 天气, 时钟
* 按序处理
* 异步传递元素. 发送之后当前线程立即返回
* 非阻塞的**回压**. 强制要求缓冲区大小必须有上限, 并且由订阅者控制. -> 处理无限量元素的时候不会因为发送元素过多or过快造成内存等资源的枯竭

各个框架都有自己的回压策略

例如project reactor中的回压策略:

* Missing. 没有策略, 下游应收尽收. 不建议使用
* Error. 下游跟不上上游的节奏, 上游抛出错误
* Buffer(默认策略). 下游没来得及处理的元素先存在缓存中. -> 如果不设置缓存大小可能错误
* Drop. 下游没有准备好, 就会直接抛弃
* Latest. 下游只会得到上游最新的元素

# 响应式编程接口类

Publisher(发布者), Subscriber(订阅者), Subscription(订阅), Processor(处理过程)

## Publisher

Publisher(发布者)提供任意数量的元素序列. 接收到Subscriber(订阅者)发出的订阅后会根据订阅者的需求逐次调用下面的方法来进行事件传播.

onSubscribe; onNext*n; (onError|onComplete)?可选

其中注意: 

* onSubscriber肯定被调用1次, 
* 然后是0~n次的onNext, 
* 最后是onError或者onComplete结束订阅流程. 
* 订阅者主动取消当前订阅时, 可以不需要onError|onComplete, 不会再发送数据

![image-20220522204112332](img/reactive-study/image-20220522204112332.png)

```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```

只有一个subscribe方法, 可以通过该方法来指定一个Subscriber(订阅者)来订阅.

规则:

* Publisher向Subscriber发送onNext信号次数(调用onNext数量)不得超过订阅者请求的元素个数. 即如果请求3个元素不可以发送超过3个元素. -> 基础重要的原则, 保证了接受元素的先后顺序.

* 如果publisher失败, 需要调用onError告知订阅者. -> 订阅者有时间做错误处理, 资源清理等
* Publisher.subscribe()内部必须调用onSubscribe(Subscriber s). onSubscribe通知订阅者该订阅已开始 -> 为了让Subscriber做好初始化, 开始准备接受后续元素.
* 当前的Publisher允许同时存在多个Subscriber, 一个元素序列可以由一个发布者同时向多个订阅者进行发送, 类似广播 -> Publisher和Subscriber的关系: 1对n

## Subscriber

```java
public interface Subscriber<T> {
    /**
     * Invoked after calling {@link Publisher#subscribe(Subscriber)}.
     * <p>
     * No data will start flowing until {@link Subscription#request(long)} is invoked.
     * <p>
     * It is the responsibility of this {@link Subscriber} instance to call {@link Subscription#request(long)} whenever more data is wanted.
     * <p>
     * The {@link Publisher} will send notifications only in response to {@link Subscription#request(long)}.
     * 
     * @param s
     *            {@link Subscription} that allows requesting data via {@link Subscription#request(long)}
     */
    public void onSubscribe(Subscription s);

    /**
     * Data notification sent by the {@link Publisher} in response to requests to {@link Subscription#request(long)}.
     * 
     * @param t the element signaled
     */
    public void onNext(T t);

    /**
     * Failed terminal state.
     * <p>
     * No further events will be sent even if {@link Subscription#request(long)} is invoked again.
     *
     * @param t the throwable signaled
     */
    public void onError(Throwable t);

    /**
     * Successful terminal state.
     * <p>
     * No further events will be sent even if {@link Subscription#request(long)} is invoked again.
     */
    public void onComplete();
}

```

onSubscribe, onNext, onError, onComplete

规则: 

* 为了收到onNext发送的信号, 订阅者必须调用Subscriptions.request(long n)来向发布者请求数据 -> 为了让订阅者决定什么时候和如何来处理上游传下来的元素, 确保他有足够的资源来进行处理. -> 并且规范推荐在力所能及的范围内, 每次请求尽可能多的元素. 相比较每次请求一个元素会更加有效率.

* Subscriber的onComplete和onError, 不能够调用subscription或者是publisher上的任何方法 -> 为了防止在处理这两个终结信号的操作的时候, publisher和他们如果是在不同的线程上执行, 可能会出现一些静态条件
* 如果当前的subscriber有活跃的订阅, 如果在接收了另外一个订阅上下文传送的onSubscribe方法时, 必须要去调用subscription.cancel来取消另外一个订阅 -> 保证的订阅者不会同时与多个发布者发生交互, 如果不这么做, 可能因为资源泄露而产生一些稀奇古怪的bug.
* 即使订阅者已经调用subscription.cancel取消了当前的这个订阅, 仍有可能有onNext信号发送, 仍需做好准备 -> 因为调用cancel方法时, 发布者并没有保证他会立即执行, 可能发布者在真正的去处理这个取消订阅的操作之前依然会向下游去发送一些元素. 此时subscriber需要处理这些元素.

## Subscription



```java
public interface Subscription {
    /**
     * No events will be sent by a {@link Publisher} until demand is signaled via this method.
     * <p>
     *  It can be called however often and whenever needed—but if the outstanding cumulative demand ever becomes Long.MAX_VALUE or more,
     *  it may be treated by the {@link Publisher} as "effectively unbounded".
     * <p>
     * Whatever has been requested can be sent by the {@link Publisher} so only signal demand for what can be safely handled.
     * <p>
     * A {@link Publisher} can send less than is requested if the stream ends but
     * then must emit either {@link Subscriber#onError(Throwable)} or {@link Subscriber#onComplete()}.
     * 
     * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}
     */
    public void request(long n);

    /**
     * Request the {@link Publisher} to stop sending data and clean up resources.
     * <p>
     * Data may still be sent to meet previously signalled demand after calling cancel.
     */
    public void cancel();
}

```

request(long): 去请求n个元素

cancel(): 去取消这个订阅

Subscription: 表述当前发布者和订阅者之间的订阅关系的一个对象, 他会在调用Subscriber定义的onSubscribe的方法的时候传递给订阅者, 这样订阅者就获得了当前publisher和当前的这个活跃订阅的一个关联关系.

规则:

* request和cancel都必须在当前subscribe的上下文当中被调用, 确保发布者和订阅者关系的唯一性. 
* subscription.request(long)最多请求2^63-1个元素, Java中long长整型的max_value. 基本可以把它看作是无限多个元素序列 -> 如果每一纳秒发送一个元素, 如果要发送这么多元素的话需要292年.

## Processor

Processor代表处理的状态, 既是Publisher又是Subscriber

```java
/**
 * A Processor represents a processing stage—which is both a {@link Subscriber}
 * and a {@link Publisher} and obeys the contracts of both.
 *
 * @param <T> the type of element signaled to the {@link Subscriber}
 * @param <R> the type of element signaled by the {@link Publisher}
 */
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```

知道他的存在就可以了, 因为reactor框架在3.5版本之后就已经作废了processor的一些实现类, 例如MonoProcessor和FluxProcessor, 转而使用Since?

# project Reactor

## 简介









这样, 大家好, 欢迎来到这个小节的学习, 在上个小节呢, 我们对响应式流的jbm规范和标准进行了一个分析, 那么在今天这个小节我们就要进入对API实现类库的一个介绍. 在这里呢, 我们选择的内裤是project reactor, 他是响应是流规范的其中的一种实现, 当然了你也可以用JAVA或者是vertex来替代. 但是为了保持简洁明了, 我们在这里呢就先从reactor来进行讲解, 因为他是spring默认的响应式的框架. Reactor是完全非阻塞的一个框架, 并且呢他在处理无限个元素时, 能够根据订阅者的消费速度来进行调节. 也就是我们之前提到的被压reactor提供两个异步1212就类似于一个有很多元素组成的列表或者是数组, mono呢相当于一个optional的类. 它可以返回一个mt, 也可以返回一个唯一的一个值, 这个就从语意上区分的这两个序列所包含的元素的个数. 比如说如果是一个HTTP请求的话, 它只会产生一个回复. 所以这个时候呢, 你把它表示成一个model, 就比flux要更贴切一点. 同时react这个框架也提供了大量对呃响应是流的操作服务. 大家注意啊, 这个指的是reactive stream的响应式流, 跟我们在前面一张提到的jk八中的一定要区分开, 不要弄混了. 这些操作呢包括选择, 过滤, 转换, 合并等等. 我们在下一章节的实战环节中呢也会接触到这些操作服. 在这个小节的最后呢, 我们来稍微多聊两句关于flux和moo. 是一个标准的, 它配设实现它代表产生零到n个元素的异步序列. 这个序列可以选择被或者是arrow信号来终结这几个信号, 大家联想一下, 对应到响应式流中间什么事件呢？就是订阅者上的. 和on error这三个方法, 因为这三个事件信号甚至包括结束信号其实都是可选, 那么flux的用途也因此是多种多样的. 如果我们不要用nex, 但是就用了complete, 我们就得到了一个空的有限序列. 如果甚至连的也不调用的, 那就拿到了一个空的无限血液, 当然了这个序列可能啊平时除了做测试以外, 并没有什么其用处, 更多的情况下无限的序列不会是空的. 比如说你用flux点啊给定一个duration, 它会产生一个long类型的一个无距离, 那么他会按照你设置的duration根据时钟的摆动来去. 按时产生这样一个元素, mono是一个稍微特殊一点的实现, 再调用信号的时候, 它最多会产生一个元素. 然后呢通过调运行的信号来结束这个整个调用, 但是在这里面大家记住一点. 对于猫来说, 如果你已经占用了的话, 是不能够再去调用on error的. 为什么呢？大家设想一下, 如果我已经调用了, 那么不管这个朋友有没有返回值, 他是调用成功了. 如果这个时候我再去调用一个的方法, 那么这个mono的状态到底是成功还是失败了呢？这个是没有办法确定的, 所以pr小节ect reactor他呃这个框架对于mono的话, 他追加了一个限制, 就是说你的调用和的话只能二选1, 

## 流的构建

进入对于reactor的框架的实战环节, 同学们可以暂停一下视频, 然后打开你的ide, 然后我们在这一小节呢会首先着重去讲一下关于流的一个构建. 在构建流里面呢, 我们呃首先会简单的去讲一下这个项目会有哪些依赖. 然后另外的话, 我会在大家详细的去过一些关于创建的流的一些工厂方法的一些实例和一些注意事项, 在在在这里也可以看到我已经打开了这个实战的项目, 然后呢打开的这个泡沫的什么来给大家讲一下这个项目会有哪一些没稳依赖啊？首先第一个最重要的它是一个reactor, 这个的话就包含了关于这个reactor的是框架的一些非常重要的一些事情, 比如说flux这样的. 然后剩下来的两, 接下来两个是关于这个项目构建的一些测试类. 一个人tesju五这样的啊, 这两个测试的一个依赖啊, 接下来第四个呢是一个long, 这个主要是帮助我们去简单的去书写一些啊LOGO啊, 日志这样的一些记录啊, 去去让代码去看的比较简洁一些. 最后的话就是一个关于一些日志的一些依赖啊, 为了保证保持跟之前的一个一致吧, 我们这边的话还是用cg这样的一个API来进行一个日志的输出啊, 然后他底层的实现的话, 依然会使用log卡来进行, 所以我们加入了两个log的依赖在这里. 嗯, 这边呢关于流的创建, 我们会就拿我们的股价的订阅系统来举个例子吧, 如果我们要想去生成一个股票代码的流. 对, 然后基于这样一个目的, 我们有不同的创建方法来去构造一下. 呃, 那么首先我们要考虑一个问题, 就是我们应该是用struts还是大家想我们哪一个呢？啊, 因为我们这边有不止一只股票, 我可能有100个, 1000个甚至上万个呃股票的代码. 那么这里呢我们就不能, 我们需要用来代表这样多于一个元素的. 一个序列也就是我们这边的股票代码的一个流啊, 那么首先最简单的话, 我们就是用x的方法来去做驾驶方法呢, 它就是你只要把所有的元素全部扔进去, 然后他就可以生成一个, 生成一个序列. 这个就比较简单啊, 后面两个的话, 第一个是双双的话, 就是从实的JAVA的一个的这样一个interface的一些类, 比如说像链表啊或者之类的, 他就可以把它创建成一个流. 第三个的话就是从数组来创建这样一个流, 第四个是从来创建一个流就, 就是从我们JAVA的jdc八里面介绍出来的那个创建一个旅游啊, 大家这边一定要注意一点, 就是他这个文档里面其实也有些就是说这个是不能被重复使用的. 什么意思呢？就是说如果我这边已经对这个序列区已经订阅了一遍的话, 如果我再去订阅第二遍的时候是会有问题的. 大家想这是为什么呢？因为在jk八的来说, 这个当它只能被打开一次, 如果他已经被操作过之后, 这个人这是会, 所以当你再去操作第二遍的时候, 他就会抛出来一个错误. 我们来跑一下, 看看他会跑什么错误. 他都会看到他抛了一个一, 然后告诉你这个流已经被操作过了, 或者是已经被关掉了, 那么这个时候大家也就一, 对于这样一个操作来说的话, 尽量避免去订阅超过一, 我们接着往下看, 这边的话是有一个flux empty啊, 大家这边注意一下的话, 它返回的是一个空的一个序列, 但是呢因为我们这边已经定义了一个泛请就是一个那么他依然是能够尊重我们这个约, 然后返回一个string泛显的. 好, 这样一个呃一个序列. 接下来呢是一range方, 呃, 这个方法的话它会拿两个参数, 第一个参数是它的起始值, 这里面我们给的是五, 然后第二个值呢就是它的数量. 我们这边如果给三的话, 那么这个flux里面就会包括三个元素, 分别是五六. 七到期之后他就终止了, 下面是杰瑞的方法, 杰瑞的方法呢它是一个同步的方法. 并且每次generate只能有一个信号发送的操作, 这个意味着什么呢？这个意味着你在每次的generate里面不能调用多余一次的方法, 因为一个nex就是一个信号的发送, 否则它就会报错. 这个职位的方法比较有用的呢是他有一个state来让你去根据当前的状态来决定下一个发送的元素是什么, 我们来看看他的那个一个方法的. 这边的话他会有一个state, 一个generator和一个state那么这个就是这个初始化, 你要把这个c去进行一下初始化. 啊, 我们这边的话是写了一个呃序列号生成器的这样一个flux的写法. , 那么首先我会序列化这个state. , 把它设成了tommy的话, 不给这就是一个零, 那么对于瑞的方法呢, 我们每次去拿到当前的这个and就是把它增加一啊, 然后我再通过这个把这当做一个序列号发送出去. 呃, 当我发送了十个之后呢, 然后我就会把这个整个的这个刷词生成给关掉, 那么在最后我会定义一个consumer来告诉程序啊, 我这边已经结束了我这个整个的一个福克斯的生长就完全结束了. 这边比较有用的这个c consumer就是说如果你有一些数据库的连接在这个里面的话, 你可以把这个数据库关闭, 连接的操作放在这里. 这样的话就当你的呃整个flux结束的时候, 你就可以在这边进行一些关闭的一些操作, 大家看这个方法其实它比较有点像JavaScript里面的ray的那个或者是JAVA API里面的. 这个方法也是拿到一个初始状态, 然后进行一些操作, 然后拿了一个状态. 下面flux的方法, 它相比较来说的话, 它是一个异步的一个操作, 所以呢它可以有多于一个. 呃, 方法的一个回家, 他的一般的用途是把其他的一些异步的API, 比如说一些listener给集成到的框架里面了. 当然了, 我们也可以简单的去写这样一个序列, 就是去生成一个, 然后去通过去调用. 怎么来？北京两个不同的股票代码, 然后去把它关闭掉, 这样写也是没有问题的, 呃, 但是给大家来看一个更加有意义点的一个例子吧, 就是说我写了这样一个listener. 这个对他的死哪儿了？他有两个方法, 就是我会有一个回调去呃对这个拿到的数据进行一个处理, 然后另外呢我去就是当我的这个类似的调用完成之后去做一些事, 那么对于这样一个lister, 如果我要把它reactor方法里面要去怎么样去操作呢？我就可以用到的方法了, 首先这个可以怎会要定义一个sink？这个就是一个. 啊大家, 大家注意啊, 这边不像它里面是没有的, 他们拿到一个性格之后, 这个时候我可以我可以定义我的这样一个呃类似的, 一般的话, 我这边会去把我的register注册到另外一某一样某个服务上面. 然后我在这边定义, 当我接收到这个data之后我会做什么？这边的话我就会向下游去发送, 我接收到数据. 如果我结束的话, 那么那我会告诉我的, 这个think我这边已经结束调用了, 你可以关闭了这个flux. 就是大概是这样一个操作, 在这个create的方法的后面呢, 他其实会配合. 参数就是一个overflow的一strategy, 这个其实就是一个下游的一个被压的一个策略. 我们稍微花一点时间来看一下他经历了哪些策略啊？这个被压的策略呢, 呃, 大家看到它定义的有五个不同的策略. 首先第一个的话是一个这个一个弄的就是我忽略下雨的北洋, 就是我会就直接一股脑把所有东西全部扔给下雨. 啊, 如果我崩掉的话就算了, 第二个方法, 第二个策略的是如果下游消费过慢的时候呢, 他会抛出一个这样一个第三个是drop的意思就是说当你下游消费过慢的时候呢, 我就把我的这个信号的发送给做掉. 我就不发送给下游啊, 然后的意思是下游啊只会拿到上有发送的最新的一个信号. 这样的话, 如果你是一个实时的信息流的话, 用会是比较好的一个策略, 然后最后一个就是一个八分, 八分就是一个默认的一个策略啊, 如果当下游消费我慢的话, 它会存进这样一个buff一个缓存里面. 大家要注意的是在这里这个buffer的他是会无限增长的, 如果你一直消费不及时, 然后这个把分一直累积的话, 它会造成你内存的一个溢出, 所以千万要小心当地去使用这样一个在生长环境去使用这个策略的时候. 下面是flux的一个缝方法, 这个份儿方法呢它是制造一个呃就是一个订阅生成之后它才会去懒加载, 就是supply一个publisher. 换句话说就是这个圆的实力化会被推迟到你的方法调用之后. 并且只有在这个时候, 他才会通过调用我们给的这个方法在这边就是我们一个拉姆达定义的. Supply方法来对每个都有一个对应的一个数据源. 这边我又写了一个例子啊, 就是我们之前在之前在那个方法里面去生成的时候去重复订阅多次的话, 会抛一个异常. 那么大家啊来想一想, 如果这个时候我在外面去包了一层缝推迟操作的话, 那我后面再去订阅的时候, 他还会报错吗？我来公布答案, 在这个时候他是不会报错的. 因为什么呢？因为我们是两次, 他每一次都会要用这个supply方法, 从而生成一个新的flux. 所以也就是说其实我这两个他订阅的流并不是一个, 而是每次我通过supplier的方法独立调用出来的一个呃一个flux. 所以这个时候如果我订约两边就没有问题了. 那么最后一个方法呢是因切过方法这个林成果方法, 大家可能在之前的四爱的里面也有看到过, 就是说我这边会定义一个, 然后他会按照这个时间间隔来按时去发出这样一个元, 这里面呢我们需要用点, 然后这个让这个当前的这个测试方法呢就是去进, 避免他这个测试方法去过早的退出, 我们来运行一下, 看一下能跑出来的结果. 大家看到他这边话, 每隔一秒钟他就会去. 老外突出一个元素, 然后我们这边通过定点方法去把它打印出来, 在这里面呢. 大家不知道你咋有没有注意啊？这里面的这个方法所运行的线程是parallel-1. 然后呢我们这个测试方法就是我打log的这个呃这个线. 他是我们的主线程. 从这里大家可以大概看到就是整个reactor, 他就是一个默认异步非注册的视线. 就是他的方法都会在另外一个单独的一个县城里面去跑具体rex框架里面的现场模型的. 我们就稍微卖个关子, 留到后面再来讲. 

## 流的操作

小姐, 我们简单的介绍了如何创建一个响应石流, 那么在这一小节呢, 我们会开始去介绍一些如何去操作创建出来的这些流. 提到流的操作, 却绕不开一个最基本的操作就是订阅. 在框架中呢, 他提供了以下几种瘤的订阅方式, 我们来结合代码来看一下. 首先第一个他是一个最基本的一个订阅, 这个不会打印任何东西, 他只会去触发这个流的一个生产的一个过程. 但是我们先来看一下这个log函数啊, 这个log函数是那个flux上面提供的一个方法, 他在做代码调试和帮助我们理解react的内部做了哪些事情的时候其实是很好的. 我们先来跑一下, 然后看一下这个log里面有哪些信息是打印出来的. 我在看到这个最简单的方法呢, 对于一个来说, 它打印出了一共有六行日志, 我们来逐行分析一下. 第一行的是一方法, 它调用这个方法之后呢生成了一个然后在这个里, 我们的订阅者去请求了无限多个元素, 就是告诉我们的flux, 也就是我们的发布者, 呃, 你有多少的元素请全部发送给我, 那么当我们的发布者帕贝尔接收到这个请求之后, 他就会依次调用将这个呃, 元素发送给下游, 所以就是这边的第345行. 那么当整个送结束之后呢, 他会调用uncle去结束这个发布, 就是告诉我们的订阅者, 你的这一次订阅已经出了呃如果中间有错误的话, 那么他就会在这里调用on error去, 呃, 也是会结束整个一个发送的过程, 所以这边总结起来的重点就是一次调用request请求无限多个元素. 多次调研向订阅者发送元素以及最后的调用, 结束整个的一个发送过程第二个我们来看一下一个带着handling的这样的一个订阅模式. 啊, 首先我们要定一个会抛出异常的这样一个响应式的啊, 这里话我就简单的写了一个flux, 然后它是会送1234. 啊, 这四个元素当这个元素的值小于三的时候就正常发送, 如果大于三的话, 那么我们就抛出一个异常, 大家看到这边的subscribe的话, 这个订阅方法它其实是有两个. 来定义了消费者, 那么第一个消费者呢就是一个正常的元素的一个消费, 他会我们这边只是去简单的打印一下一个日志. 那第二个消费者就是我们的错误, 消费者这边的话通过第一个参数我们是可以拿到这个错误的信息. 他是一个格式, 因为我们这边是一个村出来的一个exception, 那么我们可以在这里面去给他的啊看他的错误信息以及做一些其他的一些操作. 我们这边也跑一下, 去看一下它的运行结果. 在看到在这里的话, 123那就是正常的去打印出来, 那么当我第呃打印第四个元素的时候, 因为我第四个元素抛出的异常, 所以相应的在这边的话, 它会记录下来这个异常. 下面一个订阅呢相比较上半年就多了一个consumer. 这个就是当我们整个订阅成功完成的成的就会去运行, 一般来说的话就是用途就是说你去通知其他的一些服务, 表示说你的订阅已经完成了, 大家在这边要注意的一点是我们的consumer就是我的43环境的这个兰姆. 和第44号的这个打印的这一行, 他们是不能够同时去被触发的, 这是为什么呢？因为作为一个flux来说, 他要么去调用或者是调来结束, 它不可能两个同时去调用吗？那么相对应的你调用的时候你就会触发你的complete. On arrow呢就会触发你的, 所以这就是啊, 大家要记住这一点, 他们两个是不会同时出现在你的运行的时候. Ok, 那么下面一种情况呢？这个相, 它又多了一个叫substitution consumer的一个拉姆达表达式, 这边的话有各种不同的况, 我们来分类讨论一下, 第一种小学生consumer呢就是说我呃作为一个闹纸, 然后穿进去, 也就是这个就跟我们前面一样, 就没有传任何的consumer. 在这个时候呢, 呃, 框架会默认帮我们去请求所有的元素啊, 这个时候我的flux的话, 它就会返回我所有的1234并且打印出来. 然后第二种情况呢, 我请求的元素的数量少于这个flux里面的这个元素. 这个时候大家想会发生什？这个时候的话, 我的订阅就会只返回我请求的这三个元素, 也就是123. 那么第三种情, 当我去请求的元flux里面的元素数量的时候, 大家想会发生什么？它会还是会怎么样？好我来公布答案原始数据如果你请求的元素多于啊flux或者是一个响应式表里面现有的元素的话, 这个请求会在返回他所有的元素就是1~4之后直接结束掉. 他并不会说他去等着那个第五个不存在的元素去返回回来, 这个是没有的, 他会在返回所有的之后结束掉整个的发送, 那么在第四种情况呢？我直接就没有去啊, 没有去定义这个, 我直接就把他cancel掉了, 就代表说虽然我这个订阅, 但是我在订阅的一开始出发的时候就取消了这个地狱, 那么这个时候不会发给我们任何元素, 那么有意思的是最后一个情况最后一个情况的就是说我这边利用一个, 也就是说我没有像上游这个发送任何请求, 没有request, 没有cancel. 那这个时候会发生什么呢？这个时候这个flux大家一定记住了, 这个flux是不会结束的. 永远不会结束, 所以当这个时候好比说我这边去把它定义成在这个时候, 如果我去啊调用这个, 调用这个去访问的时候, 大家看的什么？大家看到只有一个, 对不对？他就没有一个或者之后的东西. 这个程序结束呢是因为我的整个这个测试的方法结束了, 而并不是说我的这个flux他真正的是运行完成了. 最后来带大家看一下呃比使用这些拉姆达的来记忆的一些consumer. 更加复杂一些, 但是功能会更强的一个订阅方法, 那就是使用rex框架提供的一个背景来进行订阅. 框架的推荐, 我们通过继承被对的, 这个抽象类的方法来写我们自己的一个最简单的一个需要我们重写. 户口on和hook on方法. 我们首先来看一下在这个里面默认在创建了这个subscription之后, 他的hook方法会通过调用request的这个方法来把所有的元素一次性给请求出来, 也就是一个这样我处理起来就会怎么样？就相当于是一个没有被压的, 对不对？相当于说呃我跟我跟我的发布者说你有多少元素请你通通发过发给我. 这个呢在某些业务场景里面肯定是有, 那么大家看看我在这个里面怎么样去写一个最基础的背压啊？首先我们在创建了这个之后就是这个调用这个户口的方法, 我只请求了一个元素. 然后等到发送者发送给我这个元素之后呢, 我把它打印出来, 相当于这边就做了一个处理, 并且我在请求下一个元素. 这样的话就相当于说由我们自己写的这个自己来控制我们消费的速度. 而不是一股脑的说你元素全部发送给我, 我呃当你去调用我的的在处理, 这样的话很有可能就会出现一些问题, 当然了, 此外的话, 那个reactor框架这个也提供了一些其他的一些互个方法. 你可以通过重写里面的一些户口啊on error, on cancel和finally这些不同的方法来定义这整个的一个行为. 这一块儿呢关于被一些源码的一些探探索, 就让啊同学们自己课后去看一看. 这么多不同的订, 有同学就会问老师我什么时候该用去做这样一个？什么时候该去继承来写这样一个比较复杂的一个订阅者？我觉得最直接的一个答案就是你需不需要在消费端去定义这样一个被压的一个操作. 兰方式的, 你看到除了最后一个以外, 他都会默认求无限多个元素, 从而呢就相当于是禁用了这个被压的功能. 如果被压的功能不是你的一个重要的考量的标准化, 那么用是没有问题的. 否则的话, 你就必须得去自己写自己的本, 然后通过复写里面的方法来实现你程序的一个这个被压的操作就是对你自己的处理进行一个一个管控. 前面我们已经讲完了. 流出的和, 那么下面呢我们来看一下位于他们之间的一些中间操作. 在reacto, 这些中间操作会作用在发布者上, 并且呢将它包装成一个新的实例. 这样的话, 从原始数据产生的第一个publisher经过多个直到被一个subscriber订阅消费结束整个流程. JAVA是比较类似的, 我们先来看一个比较常见的用法. 首先呢最常见的还是这个map的用法, 它需要一个方式接口的呃类型作为入参. 也就是他的maple, 并且呢他会按照maple的逻辑对元素进行一些处理. 我们看一下最简单的例子, 首先这边我定义了一个flux, 它的range是从1~4, 然后呢我这边的是定义是将每一个元素乘以二. 这边的话, 我用记录查看执行的内容, 并且用一个空的方法让来让元素真正的去向下游传递. 那么当我去真正的去跑这个方法的, 我们这边会看到我这边已经将所有的元素啊都乘以二, 并且就用了下想法. 那么下一个方法呢是f对每个元素都根据这个来进行判断, 符合条件的会向下去传递. 这边呢在这个例子当中, 我们还是用1~4来距离, 呃, 并且我们这边说一下的条件是呃只会将偶才会满足条件, 所以当我去对这个filter出来的flux去进行一个日志内容的查询的时候呢, 我应该只能看到二和四在这个里面. 所以大家看到这边是只有二跟四. 进行了向下游的一个传递. 下一个操作就稍微有一点意思了, 他是八分, 八分呢它会把上游传递过来的元素组装成一个分段的列表, 当当前offer当中累积的元素数量达到我们设定的缓冲大小之后呢, 他会把这个列表向下传递, 那在我们这个例子当中呢举例说明, 我们这边是呃range的是从1~40这40个整数并且呢我设定了我的buffer的大小是三, 所以呢就会三个元素一组向下传递, 我们来看一下运行的结果. 大家看这边运行完了之后, 它会将123组装成一个列表, 然后向下游传递456就装成一个列表向下游传递, 然后依此类推, 所以看到你这边x的元素其实是一个list of. 那最后一个元素不满三个怎么办呢？大家这边看一下我这个最后一个元素, 按照每三个一组的话, 所以40是一个单独的一个. 那么实际上呢我们看到最终是直接将这个40这个单独的元素打印了出来. 所以呢那缓冲区的元最后一个元素如果是只有一个的话, 即使它不满我们的设设区的大小, 但是依然还是会呃继续向下游去发送. 下一个方法呢是retry, 顾名思义的意思就是从事他会在这个stream的传递过程当中任意一个地方如果报错的话, 那么他就会重新的去订阅这个发布, 你在这里呢. 可以去指定这个的次数, 这边我们是指定的是三次, 也就是说他最多会去retry三次. 那么如果三次没有成功的话, 就会呃束掉整个的一个定义过程. 那在这里的话, 呃, 他一般用在的是比如说你要去调用外部的一些API, 但是可能由于某一些网络原因的话, 这个API可能会报那去模拟这个场景的, 我这边就用了一个model from supplier来定义这样一个string的一个呃一个source. 这边的话, 我给你的他的random大于0.01的时候, 就会报错也, 也就是说有99%的概率会出错, 那么当我去运行这个程序的时候呢, 我们就会看到如果调用这个抛出了异常的话, 你就是这一行的issue. 那么他就会再次去retry这个error这个订阅. 那这次retry呢？继续发现, 那么他会去再去传一遍, 这样的话, 一共三次, 加上我们之前的第一次的正常交友, 就会一共有四次去调用这个调用这个阅的这样一个操作, 所以呢这边是在我们去调用外部函数的时候是非常有用的一个操作. 在的时候呢, 大家还要记住, 因为它会消费整个stream, 所以呢你需要特别注意元素重复消费的问题. 特别流当中, 我们来看下面一个例子啊. 我们参照前面我们讲到的呃creation的方法, 我们这边创造了一个flux generation. 那么我们这个呢是从零开始生成元素, 那么到了第十个的话, 呃, 我就抛出了一个错误. , 也就是说我这边的generation就是一个从零开始, 0~9, 然后是抛醋的这样一个过程. 这个时候如果我设定了是一的话, 并且去想大家看一看会有什么结果？好, 这边跑完之后大家看一下, 第一次当我们去消费0~9之后呢, 到时的时候他就开始抛错然后, 然后告诉我说你这边抛出了一个runtime exception. 然后这个时候动作就会重新的去订阅这个发布. 于是我们又从零开始消费了一点, 也就是说这边0~9其实都是属于一个重复消费的一个状态. 如果你在这个subscribe之前的一些处理没有做好, 对于重复消费或者密档的一些处理的话, 就很容易出问题. 这里呢是大家在使用retry的时候要千万注意的一点, 那这边的71和72大家可以看到, 其实它还有一些可以定义一些呃fix或者是也就是定场的延迟或者是退避策略的. 这样一些错. 写法, 大家呢可以去看一下的文档, 然后去了解一下怎么样去做这种. Exponential by的一些女传. 下面一个方法的是zip, 这个zip的作用呢就是将两个响应是流合并成一个流. 我们来看一下这个用法. 在这里我定义了flux a代表里面有元素1~4, 那么它里面有元素5~8. 并且然后我们在flux a上面去zip with, 然后给定这个flux b, 也就是我们的目标的一个呃响应式流, 还有呢就是我们的就是如何将两个对应位置上的元素合并在, 我们这边是简单的做了一个商家, 然后我进入一下这个, 并且去真正的用去触发这个操作. 我们来跑一下进行下降, 所以得到了6, 8, 10, 12这四个数字, 这里要注意的一点呢是这个zip的操作, 它会直到两个流其中的任意一个元素耗尽的位置, 比如说我的xa, 如果有五个数1~4, 然后我的b呢有五个5~9这五个元素的话, 那么我去运行这个东西的时候, 我依然只会返回6, 8, 10, 12, 因为当中b中间的第五个元素, 他并没有对应的x的元素去跟他进行结合, 所以呢他最多他就被抛弃了. 在这里呢要注意的一点是这个zip的操作它会知道两个流其中的任意一个元素耗尽的时候就结束了. 那比如说我的当中有四个元素, 1~4, 那如果我的flux避风当中呢还有五个元素5~9. 那么这个时候我把两个呃flux, zip在一起的时候, 什么？他最多依然只能产生出四个元素, 因为中是只有四个, 当我的b当中的第五个元素九想要去找a, 跟他去进行一个合并的时候, 是找不到它对应的元素. 所以呢我们看到这边跑车的结果依然是只能返回六, 八十, 12这四个元素. `

## Scheduler的使用

讲完了响应是留的一些操作, 下面呢我们来讲一讲reactor框架中的线程和schedule的, 也就是调度器呢, 它并没有强制我们去使用某一个并发模型. 所以呢作为程序员是可以自由的去选择执行model和flux的操作现场的. 并且摸到和flux的不同操作是可以分别在不同的现场上去完, 这里呢我们来分几种不同的情况一起来看一下. 首先呢, 我们直接在测试线程中定义一个moo去跑. 那我们在这个地方的方法当中进行了一个moo, 并且做一个简单的一个map. 在的方法当中, 我们定义这个consumer啊, 来去打印出当前执行的这个线程的名称, 好, 那我这边去跑一下, 看一下结果. 我们可以看到这边其实执行的现成的它的名称叫妹, 也就是我们去跑这个测试方法的一个主线程. 那么第二个方法呢, 我还是跟之前一模一样的一个呃对于mono的这个详细流的操作, 只不过我定义了一个新的线程t, 并且我在这个匿名县城当中的去呃出发了一个线程去做的这个呃对于这个响应式的操作. , 看一下这边可以呃给我的这个现成的名称是什么？大家可以看到这边其实爆出来的现成的名称呢, 就是我们给定的这个呃他所跑在的这个匿名现场上面的. 他的名称就是杠一, 那么以上两种呢就是默认在不指定任何线程的情况下. 他会去subscribe的当前的触发线程来作为调用整个响应式流从头到尾操作的线程. 如果我们要对响应时流的操作执行模式做任何定制化的, 就必须要用到它定义的schedule调度器了. 他跟c中的xq service差不多. 都承担了一个较度的任务, 但是他的功能会更强大一点, 我们以为例来先讲一下这几种调用schedule的方法. 首先第一个呢是schedule到immediately, 在这个情况下, 他相当于就没有指定任何线程执行的上下文. 他直接会使用当前啊的线程来执行我们的. 操作所以这边看到这边的情况跟我们的第一种方法非常类似, 就直接在当前的主线程上去调用的这个方法. 第二种呢schedule到single. 当你指定schedule到single作为你on the schedule的时候呢？他就会在一个可以被复用的线程上来执行我们的p操作. 这个时候啊, 我们来跑一下. 大家看到这边教育的结果呢, 显示的是说我们这边真正的去执行这个的现场是叫single杠一, 这也是schedule到single, 他给定的这个现场. 下面一个呢是elastic, 这个elastic莫名思义就是弹性的意思. 他会将多个subscribe操作呢都放在一个弹性的线程池里面进行, 这个线程池可以无限的增长, 当然了这样的话就容易造成产生了过多的现成的一个情况, 所以不建议在比较高流量的生产环境去使用. 他稍微更保险的111个呢是这个邦德的伊拉克的方法. 大家来看一下这个方的的一些定义啊, 在他的这个当中的定义呢. 他给定了一个, 首先第一个是帮在这个就是他工作的现成的数量. 这边他话是给呃是十乘以呃当前的可用的CPU核心的数量. 咋了？你也可以通过这个react到到default on the size来对这个系统的属性进行呃进行设置. 第二个属性呢就是这个default size, 这个顾名思一样, 它就定义了操作的等待队列的长度, 那这里面最多是默认情况下可以有10万个呃任务处在呃在处理的队列当中. 同时呢这个就代表这个线程池是一个弹性的, 如果他空闲了超过60秒的话, 这个线程就会被回收, 大家看这边的有很多配置都可以通过property去指定的, 呃, 如果有需要的话呢, 可以去看一下文档来进行一些配置这个帮的elastic呢, 他很适合被拿来做一些阻塞的进程的调用, 比如说你的但如果是一个的调研的话, 当你需要把它融合进你的响应式编程的时候呢？你可以直接向下面这样去调用它, 首先你先用一个把它包装成一个. 并且呢你通过调用来定义说这个model的调用需要放在我的帮助里面. 去执行, 这样的话呢, 我就能够保证我的全部都是从这个帮的的这个线程池当中去进行执行. 那最后呢还有一个schedule, 那这个拍照的话, 它一般是拿来做一些并行计算球才会用到, 那我们在这个model里面的就不去做过多的展开了. 



## publisherOn和subscriberOn的区别

讲完了关于响应式流的执行线程的配置, 也就是通过定义不同的schedule, 下面呢我们来讲一下刚刚例子中我们用到的这个方法. 框架呢提供了两种方法来让我们改变执行的, 分别是subscribe和他们都会接受一个schedule的作为入参, 并且呢把执行的上下文切换到传入的schedule上. 那在这一小, 我们来结合例子判断出来和的区别, 首先呢我们来看一看, subscribe on它其实是作用在小process上的, 也就是在发起, 订阅的流程上, 那我们是什么时候会发起这个医院的？当我们去调用方法的时候, 我们就发起了这个订阅. 所以呢你不管把这个放在我们这个定义的定义的flux操作的哪一个位置对对在这个我们定义的一个比较简单的on的这个方法帮助, 我定义了一个流, 并且呢当他在定义的操作之后, 我指定了我要去通过这个s这个schedule. 来对他进行一个这样就相当于告诉啊我的程序, 当我在发起我这个订阅作的时候, 请你把这个执行上下文交给到我的这个s. 所以呢即使我的, 我的这个的动作是从我们的这个匿名的这个线程去发现. 那当我去跑这个程序的时候, 我依然是看到我所有的future和map的操作都是从这个我定义的这个schedule上面去发起的这个呢就是一个最简单的作用. 那我们这边稍微去覆盖一下一个比较极端的, 那好比说我这边小心我定义了另外一个, 我给他另外一个这个. 那么我不小心在我这个flux的定义的过, 我又重新去覆盖了我这个小蛋糕. 然后并且给进了他的s二这样的一个, 那么这个时候大家才会发生什么呀？我们来跑一下, 去看一下结果. 大家看到这边跑完之后呢, 其实真正起作用的这些filter和map的话, 依然是在我定义的上面去进行的, 也就是说我这个私家的s二是没有起作用的. 这个也是符合预期的, 因为呢对于整个的一个响应是流的操作链上面定义的, 如果出现多个的话, 它只会由第一个会生效, 后面的一些呢都会直接被忽略不计. 讲完了小孩下面呢我们来看一看, puppy跟on非常类似, 他也是直接定义在响应时流的链路上. 它的作用域呢是在它的下游操作, 所以在这个例子里面它的作用就是这个map操作. 具体的来说, 当他从上游接收到的元素之后, 它会在这个schedule的定义的执行上下文当中的去调用下游的方法将元素进行传输, 并且所有的后续的操作服务. 都会默认在这个线程上去执行, 我们来直接跑一下这个测试用例去看一下. 大家看到在这里呢, 当我们发起音乐的时候, 我们其实是在这个匿名县城里面去执行的操作, 所以大家看到我的从source到之前的这个, 它其实都在这个匿名县城上执行的. 那奥姆经历了之后呢, 根据我们之前的一个规范, 他会从定义的线程池当中取一个来作为执行线程. 所以这边的map方法呢, 我们看到这边的方法会从demo这个操作内容去执行. 那我们这边再来看一看另外一个极端情况, 我这边去指定了多个. 这边呢我给定另外一个加了, 那这个可能是一个提出加购的一个家去了, 并且我把它在了filter的前面. 我们再来跑一下, 看一下这个结果. 大家看到吧？那我这边第一个publish on s二呢, 他这个作用其实应该是在42~47行之间, 也就是这个filter操作. 所以我们看到在这个日志当, 我这个filter操作是在我p two杠1-, 也就是我这个s二的schedule当中去. 操作的也就是我的s二那, 那么对于下面一个map操作呢, 我们来看一下. 这边的卖操作它是由于我们建议的, 所以呢它是在s这个schedule的上面定义的线程去操作的. 这块儿跟我们去声明多个subscribe我们的情况呢稍微是有一是有一. 那最后呢我们来看一看, 我把结合在一起放在一个调用链路上去执行, 是什么样的一个结果？我直接去跑下. 现在看到啊, 其实我这个它的作用域是从定义我这个be的动作是你就是我的订阅操作开始. 然后呢他是从响应式流的这个源头就开始作用的. 一直作用到我出现了pap, 所以呢他真正起作用的是在65行到70行之间的这个操作, 那么看到在71行操作之前呢就是这个filter操作. 他其实是用了这个定义的这个感觉. 那么当我去在71行定义了这个之后呢, 这后面的操作的上下文就被p一这个schedule给接管了, 所以大家看到因为我的map的话, 它是在我的也就是我的p一的. 这个家具的上面去. 所以当大家以后要去分析和的作用域, 就可以用这种方法来进行推理. 







# Flux的并发执行

课堂, 在这一小节呢, 我们来讲一下flux的并发, 执行的并发执行呢中的的里面是比较类似的. 都是为了充分利用当前计算机都的一个特性来把一些适合拆分的任务呢进行并发处理. 当, 这样的话, 他们使用他们所要考虑的问题也就会比较类似, 比如说一些资源的共享与竞争等等. 那怎么样去呃创造和执行一个的并？我们可以直接在这个上面去调用它的方法, 这样呢我们就得到了一个flux. 在这个拍照方法当中呢, 你也可以去自定义你需要的一个并发量. 但如果你没有给定的话, 他就会默认的去用这个default size, 那这个default呢其实就是你的CPU的这样的一个核心数. 大家在这边要注意啊, 如果我直接对这个parallel flux去进行一个操作的话, 比如说我在这边去进行一个那他还是直接就在我的主线程上去执行了, 也就是说他并没有去触发他的并发的执行的这样一个操作. 那要想让这个拍到真正的并发执行的, 你需要在这个parallel flux上面去调用它的run方法. 并且呢提供一个sched, 这边呃reactor框架是建议我们直接用用这个运用于并行计算的开料的这个建议, 好的这个私家了. 来进行呃任何的一个并发操作, 我们来跑一下, 看一下这里我们定义了run on之后呢, 我们就可以看到我们这边subscribe的人的时候. , 我的这个就真正的在不同的线程上得到了执行. 治理啊, 对于我们用定义的和我们自己写的一个实现类的处理方法呢也会有一些不同. 我们来看一下, 当我们使用来调度的时候呢, 就是我们刚刚跑的那个情况, 他会直接在每个并发的线程上执行这个拉姆达定义的消费操作, 也就是说他会执行在不同的线程上. 但是如果我们是通过这个自定义的这个来操作的, 我们来跑一下, 看一下结果. 啊, 我先把需要的一些内请给或者进来, 好, 那么我们来执行一下这个方法. 大家看到这边其实我的全部都是在同一个线程上, 也就是这个parallel one上面去完成. 比如说这边其实他并没有做一个并发, 那这是为什么呢？我们来看一下这个被不同方法签名重载的这个方法. 那对于我们提供了一个的时间内的时, 我们可以注意到他这个实现的方法当中有一个方法. 那就是这个sequential会把所有并发执行的r他合并成一个rear, 所以呢这里的打印就变成了同样一个现成了. 那我们知道这个sequential的意义呢就在于把这个parallel的这个flux转换成一个正常的一个flux, 那么这个呢也是通常经常会用到的一个做法就是好比说我这边使用flux进行了某些处理之后呢, 我需要把这个再转换成一个正常的flux去进行操作的时候, 我就可以用这个seal的这个方法. 我们来看一下这个例子, 那这边的话我对这个拍摄flux去进行一些操作, 并且呢我进行了一个来对它做了一个map, 那当我这个计算结束了之后呢, 我可以通过这个手把它再转换成一个正常的一个flux. 随后我就可以沿用我的flux和的这些响应式流的操作来对这些数据进行后续的一些处理. 那这个时候如果我尝试着去用这种定义的这个再去进行一个打印呢？我就会看到他们就会被打印在同一个线程上的, 并且呢这个线程排到三是这个. 

# 处理实时流

大家好, 欢迎回到今天的课堂, 在这一小节呢, 我们要来讲解对于reactor的框架当中实时流的处理, 到目前为止啊, 我们例子中所讲到的所有响应式流都代表, 了一个数据的序列并且在我们订阅到这个发布者之前呢, 他是不会改变的, 但实际上发布者也分为两大类, 实时的和非实施. 我们之前的描述就符合了非实时流的这样的一个特征, 那在这个类里呢, 发布者只有在订阅者的时候才会生成数据向下游传播. 如果没有订阅的话就没有数据生成了, 那实时流呢他就正好相反. 他并不依赖于有多少个订阅者, 他们可能从创建之初开始就开始向外发送数据了. 并且在当有新的订阅者订阅的时候会个发送的过程, 那这个数据的序列呢可以是无限长的. 从订阅者的角度来讲, 他就只能看到他开始订阅之后的实时数据了, 那他订阅之前的那一些历史数据呢对他是必不可见的, 这个实时留的一个例子就是当前市场的一个股价. 这个股价不管有多少订阅者都是近期向外传播的, 你可以在一天中的任何一个时间来订阅这个股票价格的数据源, 并且呢从订阅生效开始. 那一客气得到一个实时的数据, 那我们要怎么样去创建一个实时流呢？那rex框架给了我们一个sink类, 能够通过代码来构建一个实时流. 我们来看一下, 首先呢我们建议一个many的这样一个呃一个sink类它的这边我们建议的一个泛型实习记者, 然后这边我们把它定义成一个hot代表, 它是一个实时流. 这边我们就用他给进了一些静态方法来代表这边一个multi cast. 然后呢？并且它是一个软的一个呃发送的一个数据源. 然后我们对于这个since so many的类呢会用一个转换的方法来对它进行一个转换. 直接去调用的方法来把它转换成一个我们熟悉的一个类型的一个流. 那下一步呢？我们去定义一个. 敬业者, 这个意面者就是在我们这个旅游真正发送数据之前就已经开始了进行一个数据的订阅. 那这边的话, 我去. 像我们订阅的每一个数据. 进行一个打印出来. 我只是先简单去打印, 然后呢我们可以直接去调用这个号上面的一些方法. 比如说mx就是代表说我要想去发送一个事件. 那这边呢我给你的元素是一, 并且我是feel fast. 就代表他会如果发送失败的话就直接退出. 或者你也可以去通过一些另外的方法, 比如说我也可以用. 就这样一个操作. 那这样的话, 我就可以说在这里面去抛出一些异常. 就这样, 那接下来呢我们在这个发送的两个数据之后再去添加一个订阅的, 这就是我们第二个订阅者. 他同样的对于第二个订阅者, 我也去呃简单的对这个订阅之后的数据进行一个打印. 那在此之后呢, 我会继续去发送. 第三个和第四个就是, 分别是三和四. 最后我就用方法来结束整个音乐过程好, 我们来跑一下, 看一下结果. 看到跑下来的结12三次, 那么对于二呢, 因为它是在发送的前两个元素之后才加入的订阅. 所以那对于这个来说的话, 他只会干到三和四. 这里呢我们就看到元素的生成和有没有被订阅是完全独立的两个事件. 这个呢就是一个简单的实时流的一个实现过程, 那我们要怎么样去创建一个实时流呢？excExcel框架给了我们一个sink类, 能够通过代码来构建这样的一个实时流, 我们来看一下这个代码的示例哈. 首先呢我们需要去定义一个类的这, 这边的话, 那其实对应的就是一个多元素的一个数据, 相当于我们的一个x. 然后呢然后我去听法的好代表是一个诗人, 然后这个创建的话, 我们直接去调用things里面它的一些内部的构建方法就可以了. 把这个转换成一个可以被操作的一个flux这样的一个响应式流的一个接口. 直接教育他的方法, 那在我定义好了这个之后呢, 我去给这个flux这个添加一个来调用它的. 方法, 那在这里的话, 我只需把它给打印出来就可以了. 一定是扫车一那在定义完这个订阅者之后呢, 我们就用上面的方法. 来发送几个元素. 这里呢我定义它的handler是fell fast, 也就是快速的失败. 这边我创建两个颜色, 呃, 发送两个颜色之后呢, 我们再向这个flux上面去添加一个. 这个就是啊. 在我们建议完这个二之后呢, 我们再去多发送两个元素, 三和四. 整个发送结束之后去调用的方法来结束这个. 整个发送流程好, 那这个就是这样一个过程, 我们来跑一下, 看一下, 结果大家看到. 我们跑完这个代码之后啊, 啊, 我们这个旅游一共呃发送了四个元素. 那我对于我的一来说的话, 我是在发送第一个元素之前就已经订阅了, 所以呢他拿到了所有的四个元素. 123和四, 那么对于我第二个扫, 由于我是在发送的中途来去添加的这个订阅, 那么他只拿到了后面发送了三根四质两个元素. 所以在这个情, 大家看到这里的元素的发送和有没有被订阅是完全独立的两个事件. 此外呢, 在一些其他的场景当中, 你可能需要去协调多个订阅者的操作, 比如说你想首先让多发起这个订阅, 然后再去触发真正的消息去发送, 那这个时候呢你就需要用到这样一个这样一个类, 那它是怎么工作呢？我们来看一看. 首先我有一个正常的一个发的这样一个流. 啊, 名称叫然后他我就直接给他定义成range的1~4. 那这个时候呢, 我可以去构造一个connect flux. 就可能的方法其实就是在上面去调用方, 把它变成一个flux. 好, 那下面呢我直接再去对这个上面去定义. 两个订阅者, 首先第一个是跟之前一样, 我们去把它简单的去做一个打印的订阅操作. 这边的话, 我听你的两个听音乐者. 然后呢我去打印一下日志, 去告诉这个信息. 我这边已经结束了我订阅, 但这个时候啊大家看到其实它并不会被触发, 所以我这边去给大家验证一下, 这边呢我暂停个三秒吧. 然后我去. 告诉他, 我马上要去开始我的那个操作. 时候, 最后呢我再去真正的去调用flux flux方法. 来触发这个订阅. 这样的, 当我去教育考那个之后, 这个就会开始向下游去进行这个颜色的一个错误. 我们来跑一下代码, 看一下结果我们来看到这边的话的确是符合了我们的预期, 也就是说当我们去定义这个的时候, 他并没有真正的去触发这个向下游发送的这个呃元素传播的这个操作. 而是当我们连接到这个flux之后, 也就是调用了耐克的方法. 随后呢我们的才真正拿到了数据, 所以呢就靠在就实现了我们之前说的让多个定位者先发起订阅, 再去处罚真正的消息发送操作的这样一个目的. 并且呢这个类似于一个broadcast, 一个广播机制. 我真正的数据语言. 笑死了, 他只生成了一份文件, 就是1234. 但是我的者一跟二他们同时都消费到了这个数据, 这个呢就类似于一个广播的. 一个央视同时呢也有一个auto自动连接的一个机制, 也就是说当我连接到这个flux的订阅者的数量达到了一定值的时候, 它就会自动的去开始这个连接, 这样的话大家都可以拿到数据. 那怎么去？那在这里的话, 我们直接去添加一个这样的一个操作. 当我第一个订阅者操作完成之后, 后面的我们显示的去调用这个考耐就其实已经不需要了. 我来跑一下, 看一下结果. 那大家在这里我其实已经没有去调用这个卡耐方法了, 那当我第二个呃, 方法呃去经历了第二个订阅者之后呢, 那就自动触发的这个这个时候马上开始了数据的传播, 然后我的发票本儿102都拿到了1234这样的一个颜色的副本. 



# **编写响应式流的测试用例**

, 大家好, 欢迎回到这一小节的学习, 那在这一小节呢, 我们来讲一讲如何去编写响应式流的测试用例, 对于响应式流的测试呢最简单的场景就是你定义了一个flux或者并且你希望去测试, 当我们去订阅这个数据源的时候呢, 他的行为是否符合预期？比如说他传发布的下一个元素是不是按照预期给了你一个特定值, 亦或是抛出了一个异常？所以当你要对这些响应直流的每一步的传播的事件进行检查的时候呢, 你就需要用到了使用再发也非常简单, 你需要在你的我的这个pom材料里面的去引入一个这个就是我们的reactor test, 并且的话一般情况下我们会给听他的scope式test, , 我们先来看一个简单的例子啊, 那在这个simple发的这个例子当中呢, 我们首先是定义了一个source这个变量, 它是一个flux. 那这个flux呃, 我们建议的操作是它的原是1~7这七个数字, 并且呢对于基数进行一个过滤, 然后再对过滤下来的基数呢进行乘以十的这样一个操作. 那么如何去利用去呃进行一个验证呢？首先我们需要去生成这样的一个, 然后呢通过create创建一个first step. , 然后呢通过create创建一个first step. 话, 我们可以直接去把这个给传进去, 那后面呢我们就可以用一些的方法来去锻炼这个它中间一些一些特定的条件. 比如说那我第一个数字的话肯定是返回的结果是一嘛一过滤之后乘以十, 所以我的这个数字是呃结果是十, 所以我就可以用来给定时. 来告诉啊, 我希望我得到的结果这第一个元素啊是我的给定的一个值. 外呢, 这个也可以有一些其他的写法, 比如说我expect matches我可以给你一个, 比如说第二个的话是三, 对吧？啊, 我给定3×10, 它可以被十整除, 所以这块儿这个凯立克但是可以是成功的, 那么这个一直在呢, 它其实可, 给定多个经记者在这个情况下啊, 那这边的话我就把后面的引起了全部都给上去, 就是五跟七被过滤之后乘以十, 所以我是跟70到最后我一在这个flux会发送一个的一个事件, 所以我一直在那我们段也写完之后呢, 我们直接去调用verify. 触发这个测试就可以了, 那这样呢就是一个完整的一个简单的一个过程, 我们来跑一下, 看一下结果. 那正常情况下, 如果呃你这个塞班的没有抛出错误的话, 那直接就呃跑出来之后就没有没有返回的异常就可以了. 下面呢我们来看一下如何去验证在这个flux或者是mono操作中可能抛出的一些异常. 首先呢我们要去改造这个色, 让他去抛出这样的一个场, 那在这里的话, 我们去给这个色去利用, 去给它添加上啊这样一个异常的这个内容. 对, 这样的话我们用是慷慨, 那在这里呢我就去定义一个异常, 这边的话我是经历了一个呃, 这个里面有给定一个, 比如说一个简单的一个软给定一个error message. 那当然注意啊, 对于这个的话, 去对他进行一个cap, 不然的话呢, 你如果你不去进行一个复制的话, 他不会在这个上面去对这个本身这个类去进行改变, 所以我这边去进行一个发. 并且呢我替换掉原来的这个首, 那这个时候如果我再去跑的话, 大家去看一下什么结果. 大家看到这边的就会抛出一个私生一个代表说我的这个断言失败的, 因为呢我这边其实并不会去抛出这个on的这个. 啊, 这个结束信号, 因为我这边是异常, 所以它会跑. 怎么样去做一个做一个测试呢？我可以利用error, 然后给另一个那这个牌的的呢的呢对这个类型去进行一个交易, 那我在这边的话就可以去听你of, 然后给定一个, 我们这边抛出的是一个run, 那我就给一个runtime, 我们再去跑一下, 去看一下他有没有成功. 那大家看到当我去替换成error, 然后给您一个正确的之后呢, 我这边的这个断言这个整个的这个呃逻辑就已经跑通了, 同时呢你也可以去对这个因此呃这个抛出来的异常去进行一些其他的信息处理, , 我这异常中抛出的一个信息是不是我想要的, 我就可以去利用它的message方法, 然后呢我去和我真正的想要的信息去进行一个比对. 这样的话我也可以去验证啊这个异常中间的一些属性. 除掉的上面这个或者这样的, 对下一个或者下几个元素的验证的, 你也可以通过考试这个操作消费掉下一个元素. 从而呢就可以跳过对数据流中某些元素的校验, 我们来看一下, 好比说这边的话, 我需要跳过对30这个元素的交验的话, 我就可以直接把这一行替换成. 啊, 这边的话, 我去把它打印出来. 那这样的话呢, 在这个时候你就相当于是跳过了30的呃验证, 并且进行了一个消费动作, 大家看到在这里的话, 我就把这个30给他打印了出来. 那这个时候如果我并不单单你是想跳过, 我想跳过某一段元素的消费, 我要怎么去做呢？那我只要把这个去换成腾讯, 然后给另一个正确的就可以了, 好比说我这边的话就可以给电影当我元素的值是小于100的话, 我就全部跳过, 那这个时候我就不需要去这一行了, 然后我就可以直接去跳到最后的啊这样的一个发送操作, 那这样的话其实也是可行的. 那大家看这边跑出来的结果的, 呃, 这个发展是成功的验证了, 那代表说我已经跳过了. 30, 50, 70这三个元素. 最后呢去给班的方法也有一个变种关于你rt that你可以在整个测试结束之后呢来对响应式流的一个状态进行一些验证, 比如说在我们filter操作当中, 我们就弃掉了偶数, 也就是246这三个元素. 那你在这里呢就可以去对这个对应的元素去进行一个验证. 啊, 那在这里的话, 我可以用has discarded来代表说我丢弃了哪些元素, 比如说我这边丢弃了二十四, 六. 你可以这样去进行一个定义, 或者呢我也可以对整个运行花的时间来进行一个分析. 我可以定一个took less 话, 我就可以对整个的呃这个x的发送和订阅的过程来进行一个呃进行一个分析, 还有一类发布者的数据源呢需要我们去注意的是跟时间相关的. 以上我们演示的这些数据源都是在订阅之后及时就生成的, 但是有时候啊一个流当中它的元素发生这么的间隔, 它的时间可能会很长. 这个时候呢你不可能去把这个测试线程开着跑一天或者好几天去测这样一个场景, 对不对？那在这里呢, 你就会希望我们有一个加速器能够帮我们去加速中间的一些间隔的时间. 那的确提供了这样一个功能. 那在这里呢, 我们就要用到with virtual time的这样的一个操作. 这个方法的入仓啊, 它不是一个flux, 而是一个我们需要在这个当中去声明, 需要测试的响应是流. 这是为什么呢？因为这个virtual实际上在后台替换了原原本. 去做这个操作的schedu, 而切换成一个叫virtual time schedule的一个对象, 那在这个一个重要的前提呢是所有的操作都要在这个virtual time schedule的生效之后. 才能被定义, 所以如果我们直接就给进了我们已经定义好的flux, 那其实相当于我的virtual对这个呃对这个是不生效的. 所以呢我们需要用的方式去传入这样一个有延迟操作的这样的一个flux, 从而使得它可以利用这个virtual time schedule上面提供的一些特性. 在我们利用每次去定义了一个virtual time schedule了之后呢, 你就可以用或者是no event去验证一下. 跟时间相关的一些操作, 我们先来看一看, 用比赛的一个It felt no event now他顾名思义是指我们期望在给定的时间内没有任何事件传播. 那如果你直接把它当做第一步去使用的话是有问题的, 因为呢它前面总会有一个description这样的一个event. 所以为了防止他直接就验证失败了, 我们一般需要在前面去加上一description. 这样的一个断言. 我在给定呃接下来的一天可能都没有, 都不应该有任何疑问的发生. 然后呢我去验证, 我第一个拿到的元素会是零. 然后呢在这里我们去用一下then awaat await就是另外一种去验证时间操作的相关的方法. 那你现在跟他的区别呢在于在他是允许在这个之内有多个信号的传播的. 甚至如果我们定义的这个时间啊, 体内操作的发布者在我们定义的这个duration之内发布完成也没有问题. 在这里呢, 我们先去await为1000. 再去验证我的第二个元素是一, 然后呢我就可以去把我整个的验证流程就完成了. 下面问大家一个问题. 那在这个方法当中, 如果我直接去await了三天, 也就是超过了我这个interval的, 他take two的这个两天的这样的一个时间的期限的话, 我的一代应该怎么去写呢？那他超过了这个duration, 对吧？那其实的话我们还是得从他的第一个元素来进, 因为这边的话我必须要首先去还给定他的第一个元素是零. 然后呢？再去expect他的第二个元素是一然后去complete. 这里大家要注意的一点是, 即使我给定了位置了, 它的时间跨度超过了我把它定义的这样的一个时间跨度, 我需要从第一个来进行验证. 这一小节的最后呢我们来聊一聊这个东西, 他是拿来做手动触发数据传播使用. 跟我们在讲到实时流时候提到的since有一些相似, 但我们需要对响应式流事件触发有更细力度的掌控的时候呢. 我们就可以利用去写这样的一个单元测, 我们首先来看一看它一个简单的用法. 那去创建, 我们只需要去调用这个方法就可以了, 然后如果如果我们要在这个发布者当中去发布一些元素的话, 我们可以就用nex方法. 这个那个是方法的, 可以接受多个元素, 也可以接受一个元素. 那我们教练结束之后从而给到当中的所有的元素一次性的发送. 大家看到其实这里的nex和在一起的话是等价的. 因为呢我们去看一下艾斯的源码. 在他的源码当中的话, 其实就是对每一个呃我们给进的这个value基金展开, 然后调用那个方法, 最后呢再去钓个, 如果你想在这个当中直接去抛出异常, 的话, 其实就是对每一个呃我们给进的这个value基金展开, 然后调用那个方法, 最后呢再去钓个, 如果你想在这个当中直接去抛出异常, 的话可以直接去调用arrow, 然后给定一个就可以了. 就像这样. 好, 下面呢我们来看一看test publisher如何和一起在测试用例中来实现. 首先呢, 在这个例子当中, 我先通过test publisher到create来生成了一个test的实力, 并且我在fire的create的方法中那在这里呢, 我就将这个字符串转换成大写, 并且记录一下log, 然后这一步的话, 我通过调用来执行的发送元素的这样的一个操作. 并且呢跟我们这一章节之前讲到的next来验证, 我所最后接收到的元素的确是这两个复合的大气形式. 然后我在最后用verify来验证我的确接收到了靠自己的这样的一个事件, 这个就是一个简单的和在一起工作的一个例子. 这边的test publisher到create它是用来创建符合规范的. 不是, 某些时候呢, 如果我们需要去创建一些不符合规范的publisher, 从而去验证啊, 我们的operator是不是能够处理这些有问题的呢？我们需要用到一个叫create. 这样的一个方法这些不符合规范的总包括了以下的四种情形, 那首先第一个是在这个情形下的, 我们允许就用x的方法超过下游请求元素的数量. 情况下, 我们应该去触发以但是在这个不符合规范的当中呢就不会第二个是now就是允许向下游发送闹, 并且并不会触发. 那提升个是我们terminate就是允许我们的test publisher上的终结信号, 比如说on或者on error. 被多次的处罚. 那最后呢就是这个一份cancellation, 那他的意思是允许publisher在下游已经发送了cancel的情况下, 依然继续向其发送信号, 这个就好比我们前面提到的多线程操作下的一个静态条件, 我可能先发送了一个信号. 才收到的request. 呢其实一般是用在测试一些比较复杂的operator的时候会用到的, 大家在这里呢可以先了解一下它的一些对应的用法. 

# *欢迎来到今天的课堂



, 在这一章讲响应之流的最后啊, 我们来简单的介绍一下, 响应是由编程的另外一个非常著名的框架JAVA. X, JAVA呢它是netflix牵头的一个在vm上实现reactive programming响应式编程的一个框架. 那rx呢是reactive extension的缩写, 最初它是Microsoft微软的net的语言的一个响应式的扩展. 后来呢被开源出来, x是一个编程模型, 它能够提供一个一致的接口, 帮助开发者更方便的处理异步的数据流. 所以呀, 你会看到这个编程模型下的x, JAVA和js, 他们的写法几乎没有太大的区别中绕不开的一个重要的概念呢就是观察这个模式. 那整个rx的设计和实现就是在观察者的基础上. 去扩展了, 支持数据. 和事件传播的序列, 并且呢增加了很多运算符, 让我们可以用声明式的方式. 来进行对这个序列的操作和组合, 这个思想呢和我们在reactor当中对于publisher的操作是不谋而合的. 那么其中的观察这个模式呢有下面两个重要的概念, 第一个是observable. 他代表着呢实证和从数据源拿到数据的对象, 并且他的状态可以被其他对象观察到, 那么第二个呢就是observe观察者, 当他观察的对象状态有变化的时候, 比如说事件或者数据的传播据的传, 他们就会被通知到, 那这两个observable和observer呢就是通过subscribe方法和其他串联到一起. 所, 我们对一个寿司这个observable的一个操作的话, 定义一个一它会返回一个observable, 那么如果再对他进行第二个操作的话, 那么它会返回另外我这不过这就等同于在reactor当中我们的经过operator的操作返回了另外一个, 那在rx当中呢, 观察者会在处理完一个事件之后才会去处理下一个, 这样呢就保证了观察者处理序列的一个顺序. 那下面呢我们就直接进入一个代码的一个实操的环节, 去看看如何在rx JAVA中去创建一个, 首先呢我们要在泡沫当中来引入跟JAVA相关的一些依赖治理呢就是直接引用. 这个扎宝的这个fact, 我们采用了它最新的版本3.0.13. 那引入了依赖之后呢, 我们就可以开始去书写我们的代码了, 首先啊我们来看一看, 如果我们要去创造一个mono的话, 就是reactor的写法. 我们就直接用调用moo到just去定义这个model, 然后呢去订阅这个model的响应式流. 那么在当中应该怎么去做呢？同样的我们可以去进行一个observable. 然后呢给定一个发型. 然后我们直接在observable上面去调用just的方法. 并且如果我们要去订阅到这个observable的时候呢, 我们就直接同样的去调用方法, 然后这里呢也是给定一个起码就可以了, 这两个不能说是毫无关系, 只能说是一模一样了, 那简单的这个observable的创建和订阅的的确适合reactor中的mono和flux是非常的类似的. 那么甚至呢我们在这个订阅方法当中定义的多种对于呃或者是arrow或者是compassion的一些consumer, 也可以同样在observable当中找到对应的写法. 比如说对于这个例子来说, 我们来去改写一下. 我会定义一个observable. 那这里的这个observable的话, 我可以就直接去调用上面的. 方法, 然后这样的话我就得到了一个observable, 同时呢我可以去对这个我去直接的去调用这个方法, 我们来看一下这个方法签名. 这个方法呢第一个就是on的一个consumer, 我们这边定义的是打印这个max的元素, 那第二个呢就是on的这样一个consumer, 我们这边的也是打印出来. 这边几乎是跟flux或者moo当中的方法签名是一致的, 所以呢这两个框架是非常非常的类似. 那我们回到我们的PPT啊, 我们来讲一讲JAVA当中的一些不同点. 首先呢它有一些不同的base class, 比如说你在当中只有mono和flux, 但是呢在x, JAVA当中它有无效的五种. 第一个就是一个它是支持零到n个元素的啊, 这样的一个响应是流. 并且呢它支持一个被压的操作. 那第二个呢就是我们之前讲到的, 他同时也是支持零到n个元素. 但是他是不支持回家的. 第三个是single, 它是支持返回一个元素或者呢一个错误. 第四个是一个maybe, 那这个就很有意思了, 它可以返回每个元素, 也可以返回一个元素. 或者呢是一个error, 那最后呢是这个这个它不会返回元素, 但是它会返回一个或者是arrow的一个信号. 那如果要去和actor当中的mono和flux做对比呢, 其实是和maybe会比较相似, 而flux呢它会和会比较类似, 那reactor不支持其他的三种类型, 但是大致呢能匹配上, 比如说呃如果你要一个不需要返回值的一个mono的话, 你可以定义一个model void, 然后呢直接在当中去交用就可以了, 总体来说JAVA呢它将各个请进行了一些细化那代码的处理, 以上的情义就可能会比reactor更少一些. 但是这种做法是好是坏的, 就见仁见智, 下面呢我们来讲一下JAVA和reactor他们在实际使用上的一些小的区别. 首先第一个是异常处理方面, 那在JAVA当中的和reactor, 大家看到这边的话, 对于我们map当中去进行一个class for name可能抛出的异常. 我在JAVA当中是并不需要去在map方法当中就去处理这个异常的, 而强制我们去进行一个异常的处理. 那么这是为什么呢？我们在前面也有讲到reactor当中的net的方法, 它的入餐是jk中的方式这样的一个函数式接口, 那么这个函数是接口的apply方法, 上面的并没有抛出异常的方法签名, 所以为了写出这样一个符合方法签名的兰姆达表达式, 我们一定要在这个兰姆达表达式当中. 去把这个异常给处理掉, 而反之看到阿扎瓦的他的方法, 其实他的入餐并不是jk当中的方式接口. 而是JAVA自己定义的一个方式的接口, 而在这个接口当中呢, 他的方法签名上其实是有抛出异常的这样潜能, 所以你可以不需要在map方法中去做这样的一个异常的处理, 那此外呢, 他们的区别还表现在和JavaScript API或者是跟和optional的一些相互转换上. 大家看到这边其实reactor也提供了这样的一些我们上述的一些jk自带功能的类型的一些转换, 而这些功能在JAVA当中是没有的. 那最后最重要的一点呢就是他们在不同领域的受欢迎的程度了, 那reactor框架基本上是spring flux的一个标配, 它可以和spring的框架进行无缝的集成. 所以呢如果你作为一个web或者存货开发的话可能是更受青睐一些, 但是反过来说, JAVA在安卓开发中是比较流行的, JAVA加上retrofit是一个很受欢迎的一个安卓的技术站的封装, 所以呢如果你想做一些移动端的开发, 不妨也去了解一下JAVA当中的一些细节. 嗯下午回去跟我去山里面给我妈吃. 对我我知道









# Ref

* [慕课网-Spring 5实战开发及新特性精讲](https://coding.imooc.com/class/538.html)

* [慕课网-Spring Boot2.0深度实践之核心技术篇](https://coding.imooc.com/class/chapter/252.html#Anchor) -> 书本《Spring Boot编程思想(核心篇)》小马哥著








